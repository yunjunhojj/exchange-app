/* tslint:disable */
/* eslint-disable */
/**
 * 환전 API 명세서
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * API 응답 DTO
 */
export interface ApiResponseListExchangeRateResponse {
    /**
     * 응답 코드
     */
    'code': string;
    /**
     * 응답 메시지
     */
    'message': string;
    /**
     * 응답 데이터
     */
    'data'?: Array<ExchangeRateResponse>;
}
/**
 * API 응답 DTO
 */
export interface ApiResponseListOrderResponse {
    /**
     * 응답 코드
     */
    'code': string;
    /**
     * 응답 메시지
     */
    'message': string;
    /**
     * 응답 데이터
     */
    'data'?: Array<OrderResponse>;
}
/**
 * API 응답 DTO
 */
export interface ApiResponseOrderQuoteResponse {
    /**
     * 응답 코드
     */
    'code': string;
    /**
     * 응답 메시지
     */
    'message': string;
    /**
     * 응답 데이터
     */
    'data'?: OrderQuoteResponse;
}
/**
 * API 응답 DTO
 */
export interface ApiResponseTokenResponse {
    /**
     * 응답 코드
     */
    'code': string;
    /**
     * 응답 메시지
     */
    'message': string;
    /**
     * 응답 데이터
     */
    'data'?: TokenResponse;
}
/**
 * API 응답 DTO
 */
export interface ApiResponseUnit {
    /**
     * 응답 코드
     */
    'code': string;
    /**
     * 응답 메시지
     */
    'message': string;
    'data'?: any;
}
/**
 * API 응답 DTO
 */
export interface ApiResponseWalletSummaryResponse {
    /**
     * 응답 코드
     */
    'code': string;
    /**
     * 응답 메시지
     */
    'message': string;
    /**
     * 응답 데이터
     */
    'data'?: WalletSummaryResponse;
}
/**
 * 환율 응답 DTO
 */
export interface ExchangeRateResponse {
    /**
     * 환율 ID
     */
    'exchangeRateId': number;
    /**
     * 통화
     */
    'currency': ExchangeRateResponseCurrencyEnum;
    /**
     * 환율
     */
    'rate': number;
    /**
     * 변동률
     */
    'changePercentage': number;
    /**
     * 적용 일시
     */
    'applyDateTime': string;
}

export const ExchangeRateResponseCurrencyEnum = {
    Krw: 'KRW',
    Usd: 'USD',
    Jpy: 'JPY'
} as const;

export type ExchangeRateResponseCurrencyEnum = typeof ExchangeRateResponseCurrencyEnum[keyof typeof ExchangeRateResponseCurrencyEnum];

/**
 * 로그인 요청 DTO
 */
export interface LoginRequest {
    /**
     * 이메일
     */
    'email': string;
}
/**
 * 환전 주문 견적 요청 DTO
 */
export interface OrderQuoteRequest {
    /**
     * 매수 통화
     */
    'fromCurrency': OrderQuoteRequestFromCurrencyEnum;
    /**
     * 매도 통화
     */
    'toCurrency': OrderQuoteRequestToCurrencyEnum;
    /**
     * 주문 금액
     */
    'forexAmount': number;
}

export const OrderQuoteRequestFromCurrencyEnum = {
    Krw: 'KRW',
    Usd: 'USD',
    Jpy: 'JPY'
} as const;

export type OrderQuoteRequestFromCurrencyEnum = typeof OrderQuoteRequestFromCurrencyEnum[keyof typeof OrderQuoteRequestFromCurrencyEnum];
export const OrderQuoteRequestToCurrencyEnum = {
    Krw: 'KRW',
    Usd: 'USD',
    Jpy: 'JPY'
} as const;

export type OrderQuoteRequestToCurrencyEnum = typeof OrderQuoteRequestToCurrencyEnum[keyof typeof OrderQuoteRequestToCurrencyEnum];

/**
 * 환전 주문 견적 응답 DTO
 */
export interface OrderQuoteResponse {
    /**
     * 원화 금액
     */
    'krwAmount': number;
    /**
     * 적용된 환율
     */
    'appliedRate': number;
}
/**
 * 환전 주문 요청 DTO
 */
export interface OrderRequest {
    /**
     * 환율 ID
     */
    'exchangeRateId': number;
    /**
     * 매수 통화
     */
    'fromCurrency': OrderRequestFromCurrencyEnum;
    /**
     * 매도 통화
     */
    'toCurrency': OrderRequestToCurrencyEnum;
    /**
     * 주문 금액
     */
    'forexAmount': number;
}

export const OrderRequestFromCurrencyEnum = {
    Krw: 'KRW',
    Usd: 'USD',
    Jpy: 'JPY'
} as const;

export type OrderRequestFromCurrencyEnum = typeof OrderRequestFromCurrencyEnum[keyof typeof OrderRequestFromCurrencyEnum];
export const OrderRequestToCurrencyEnum = {
    Krw: 'KRW',
    Usd: 'USD',
    Jpy: 'JPY'
} as const;

export type OrderRequestToCurrencyEnum = typeof OrderRequestToCurrencyEnum[keyof typeof OrderRequestToCurrencyEnum];

/**
 * 환전 주문 응답 DTO
 */
export interface OrderResponse {
    /**
     * 주문 ID
     */
    'orderId': number;
    /**
     * 매수 통화
     */
    'fromCurrency': OrderResponseFromCurrencyEnum;
    /**
     * 매수 금액
     */
    'fromAmount': number;
    /**
     * 매도 통화
     */
    'toCurrency': OrderResponseToCurrencyEnum;
    /**
     * 매도 금액
     */
    'toAmount': number;
    /**
     * 적용된 환율
     */
    'appliedRate': number;
    /**
     * 주문 생성 시간
     */
    'orderedAt': string;
}

export const OrderResponseFromCurrencyEnum = {
    Krw: 'KRW',
    Usd: 'USD',
    Jpy: 'JPY'
} as const;

export type OrderResponseFromCurrencyEnum = typeof OrderResponseFromCurrencyEnum[keyof typeof OrderResponseFromCurrencyEnum];
export const OrderResponseToCurrencyEnum = {
    Krw: 'KRW',
    Usd: 'USD',
    Jpy: 'JPY'
} as const;

export type OrderResponseToCurrencyEnum = typeof OrderResponseToCurrencyEnum[keyof typeof OrderResponseToCurrencyEnum];

/**
 * 인증 토큰 응답 DTO
 */
export interface TokenResponse {
    /**
     * 회원 ID
     */
    'memberId': number;
    /**
     * JWT 인증 토큰
     */
    'token': string;
}
/**
 * 지갑 응답 DTO
 */
export interface WalletResponse {
    /**
     * 지갑 ID
     */
    'walletId': number;
    /**
     * 통화
     */
    'currency': WalletResponseCurrencyEnum;
    /**
     * 잔액
     */
    'balance': number;
}

export const WalletResponseCurrencyEnum = {
    Krw: 'KRW',
    Usd: 'USD',
    Jpy: 'JPY'
} as const;

export type WalletResponseCurrencyEnum = typeof WalletResponseCurrencyEnum[keyof typeof WalletResponseCurrencyEnum];

/**
 * 지갑 요약 응답 DTO
 */
export interface WalletSummaryResponse {
    /**
     * 총 원화 잔액
     */
    'totalKrwBalance': number;
    /**
     * 지갑 목록
     */
    'wallets': Array<WalletResponse>;
}

/**
 * AuthAPIApi - axios parameter creator
 */
export const AuthAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *          이메일로 로그인합니다.         - 회원이 존재하지 않으면 새로 등록합니다.         - 회원이 존재하면 해당 회원으로 로그인합니다.         - 최초 로그인 시 회원의 지갑이 생성됩니다. 잔액은 KRW: 1,000,000 / USD: O / JPY: 0 으로 초기화됩니다.         - 로그인 성공 시 JWT 인증 토큰을 반환합니다.     
         * @summary 로그인
         * @param {LoginRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (request: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('login', 'request', request)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (request !== undefined) {
                for (const [key, value] of Object.entries(request)) {
                    localVarQueryParameter[key] = value;
                }
            }

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthAPIApi - functional programming interface
 */
export const AuthAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthAPIApiAxiosParamCreator(configuration)
    return {
        /**
         *          이메일로 로그인합니다.         - 회원이 존재하지 않으면 새로 등록합니다.         - 회원이 존재하면 해당 회원으로 로그인합니다.         - 최초 로그인 시 회원의 지갑이 생성됩니다. 잔액은 KRW: 1,000,000 / USD: O / JPY: 0 으로 초기화됩니다.         - 로그인 성공 시 JWT 인증 토큰을 반환합니다.     
         * @summary 로그인
         * @param {LoginRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(request: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthAPIApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthAPIApi - factory interface
 */
export const AuthAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthAPIApiFp(configuration)
    return {
        /**
         *          이메일로 로그인합니다.         - 회원이 존재하지 않으면 새로 등록합니다.         - 회원이 존재하면 해당 회원으로 로그인합니다.         - 최초 로그인 시 회원의 지갑이 생성됩니다. 잔액은 KRW: 1,000,000 / USD: O / JPY: 0 으로 초기화됩니다.         - 로그인 성공 시 JWT 인증 토큰을 반환합니다.     
         * @summary 로그인
         * @param {LoginRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(request: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseTokenResponse> {
            return localVarFp.login(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthAPIApi - object-oriented interface
 */
export class AuthAPIApi extends BaseAPI {
    /**
     *          이메일로 로그인합니다.         - 회원이 존재하지 않으면 새로 등록합니다.         - 회원이 존재하면 해당 회원으로 로그인합니다.         - 최초 로그인 시 회원의 지갑이 생성됩니다. 잔액은 KRW: 1,000,000 / USD: O / JPY: 0 으로 초기화됩니다.         - 로그인 성공 시 JWT 인증 토큰을 반환합니다.     
     * @summary 로그인
     * @param {LoginRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(request: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthAPIApiFp(this.configuration).login(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExchangeRateAPIApi - axios parameter creator
 */
export const ExchangeRateAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 최신 환율을 조회합니다.
         * @summary 최신 환율 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestExchangeRates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exchange-rates/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangeRateAPIApi - functional programming interface
 */
export const ExchangeRateAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExchangeRateAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 최신 환율을 조회합니다.
         * @summary 최신 환율 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestExchangeRates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListExchangeRateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestExchangeRates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeRateAPIApi.getLatestExchangeRates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExchangeRateAPIApi - factory interface
 */
export const ExchangeRateAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExchangeRateAPIApiFp(configuration)
    return {
        /**
         * 최신 환율을 조회합니다.
         * @summary 최신 환율 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestExchangeRates(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListExchangeRateResponse> {
            return localVarFp.getLatestExchangeRates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExchangeRateAPIApi - object-oriented interface
 */
export class ExchangeRateAPIApi extends BaseAPI {
    /**
     * 최신 환율을 조회합니다.
     * @summary 최신 환율 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLatestExchangeRates(options?: RawAxiosRequestConfig) {
        return ExchangeRateAPIApiFp(this.configuration).getLatestExchangeRates(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderAPIApi - axios parameter creator
 */
export const OrderAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 회원의 환전 주문 내역을 조회합니다.
         * @summary 환전 주문 내역 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          환전 주문을 위한 견적을 조회합니다.         - 외화 매수인 경우, 해당 외화를 매수하기 위해 필요한 KRW 금액을 반환합니다.         - 외화 매도인 경우, 해당 외화를 매도했을 때 받을 수 있는 KRW 금액을 반환합니다.     
         * @summary 환전 주문 견적 조회
         * @param {OrderQuoteRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuote: async (request: OrderQuoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('getQuote', 'request', request)
            const localVarPath = `/orders/quote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (request !== undefined) {
                for (const [key, value] of Object.entries(request)) {
                    localVarQueryParameter[key] = value;
                }
            }

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          회원이 환전 주문을 요청합니다.         - fromCurrency가 KRW인 경우, 외화를 매수하는 주문입니다.         - fromCurrency가 외화인 경우, 외화를 매도하는 주문입니다.         - code: EXCHANGE_RATE_MISMATCH 400 에러 발생 시, 최신 환율을 다시 조회하여 주문을 시도해야 합니다.     
         * @summary 환전 주문 요청
         * @param {OrderRequest} orderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        order: async (orderRequest: OrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderRequest' is not null or undefined
            assertParamExists('order', 'orderRequest', orderRequest)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderAPIApi - functional programming interface
 */
export const OrderAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 회원의 환전 주문 내역을 조회합니다.
         * @summary 환전 주문 내역 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseListOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderAPIApi.getOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          환전 주문을 위한 견적을 조회합니다.         - 외화 매수인 경우, 해당 외화를 매수하기 위해 필요한 KRW 금액을 반환합니다.         - 외화 매도인 경우, 해당 외화를 매도했을 때 받을 수 있는 KRW 금액을 반환합니다.     
         * @summary 환전 주문 견적 조회
         * @param {OrderQuoteRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuote(request: OrderQuoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseOrderQuoteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuote(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderAPIApi.getQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *          회원이 환전 주문을 요청합니다.         - fromCurrency가 KRW인 경우, 외화를 매수하는 주문입니다.         - fromCurrency가 외화인 경우, 외화를 매도하는 주문입니다.         - code: EXCHANGE_RATE_MISMATCH 400 에러 발생 시, 최신 환율을 다시 조회하여 주문을 시도해야 합니다.     
         * @summary 환전 주문 요청
         * @param {OrderRequest} orderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async order(orderRequest: OrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseUnit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.order(orderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderAPIApi.order']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderAPIApi - factory interface
 */
export const OrderAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderAPIApiFp(configuration)
    return {
        /**
         * 회원의 환전 주문 내역을 조회합니다.
         * @summary 환전 주문 내역 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseListOrderResponse> {
            return localVarFp.getOrders(options).then((request) => request(axios, basePath));
        },
        /**
         *          환전 주문을 위한 견적을 조회합니다.         - 외화 매수인 경우, 해당 외화를 매수하기 위해 필요한 KRW 금액을 반환합니다.         - 외화 매도인 경우, 해당 외화를 매도했을 때 받을 수 있는 KRW 금액을 반환합니다.     
         * @summary 환전 주문 견적 조회
         * @param {OrderQuoteRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuote(request: OrderQuoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseOrderQuoteResponse> {
            return localVarFp.getQuote(request, options).then((request) => request(axios, basePath));
        },
        /**
         *          회원이 환전 주문을 요청합니다.         - fromCurrency가 KRW인 경우, 외화를 매수하는 주문입니다.         - fromCurrency가 외화인 경우, 외화를 매도하는 주문입니다.         - code: EXCHANGE_RATE_MISMATCH 400 에러 발생 시, 최신 환율을 다시 조회하여 주문을 시도해야 합니다.     
         * @summary 환전 주문 요청
         * @param {OrderRequest} orderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        order(orderRequest: OrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseUnit> {
            return localVarFp.order(orderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderAPIApi - object-oriented interface
 */
export class OrderAPIApi extends BaseAPI {
    /**
     * 회원의 환전 주문 내역을 조회합니다.
     * @summary 환전 주문 내역 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrders(options?: RawAxiosRequestConfig) {
        return OrderAPIApiFp(this.configuration).getOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          환전 주문을 위한 견적을 조회합니다.         - 외화 매수인 경우, 해당 외화를 매수하기 위해 필요한 KRW 금액을 반환합니다.         - 외화 매도인 경우, 해당 외화를 매도했을 때 받을 수 있는 KRW 금액을 반환합니다.     
     * @summary 환전 주문 견적 조회
     * @param {OrderQuoteRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getQuote(request: OrderQuoteRequest, options?: RawAxiosRequestConfig) {
        return OrderAPIApiFp(this.configuration).getQuote(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          회원이 환전 주문을 요청합니다.         - fromCurrency가 KRW인 경우, 외화를 매수하는 주문입니다.         - fromCurrency가 외화인 경우, 외화를 매도하는 주문입니다.         - code: EXCHANGE_RATE_MISMATCH 400 에러 발생 시, 최신 환율을 다시 조회하여 주문을 시도해야 합니다.     
     * @summary 환전 주문 요청
     * @param {OrderRequest} orderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public order(orderRequest: OrderRequest, options?: RawAxiosRequestConfig) {
        return OrderAPIApiFp(this.configuration).order(orderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletAPIApi - axios parameter creator
 */
export const WalletAPIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 회원의 지갑을 조회합니다. 회원이 보유한 통화별 잔액을 반환합니다.
         * @summary 지갑 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletAPIApi - functional programming interface
 */
export const WalletAPIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletAPIApiAxiosParamCreator(configuration)
    return {
        /**
         * 회원의 지갑을 조회합니다. 회원이 보유한 통화별 잔액을 반환합니다.
         * @summary 지갑 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponseWalletSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletAPIApi.getWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletAPIApi - factory interface
 */
export const WalletAPIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletAPIApiFp(configuration)
    return {
        /**
         * 회원의 지갑을 조회합니다. 회원이 보유한 통화별 잔액을 반환합니다.
         * @summary 지갑 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallets(options?: RawAxiosRequestConfig): AxiosPromise<ApiResponseWalletSummaryResponse> {
            return localVarFp.getWallets(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletAPIApi - object-oriented interface
 */
export class WalletAPIApi extends BaseAPI {
    /**
     * 회원의 지갑을 조회합니다. 회원이 보유한 통화별 잔액을 반환합니다.
     * @summary 지갑 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWallets(options?: RawAxiosRequestConfig) {
        return WalletAPIApiFp(this.configuration).getWallets(options).then((request) => request(this.axios, this.basePath));
    }
}



